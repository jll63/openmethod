
## Shared Libraries

This section discusses how OpenMethod interoperates with shared libraries on
Linux, POSIX-like and Windows.

### Static Linking

Static linking to a shared library behaves in the same manner as linking to a
static library on these platforms. For example, given a header:

[source,c++]
----
include::example$/shared_libs/animals.hpp[tag=content]
----

...and a shared library consisting of these two objects:

[source,c++]
----
include::example$/shared_libs/overriders.cpp[tag=content]
----

[source,c++]
----
include::example$/shared_libs/tiger.cpp[tag=content]
----


[source,c++]
----
include::example$/shared_libs/static_main.cpp[tag=content]
----


OpenMethod interacts well with dynamic loading of libraries if the platform
and toolchain make global variables truly global.

Registries contain collections of methods and classes, and methods contain
collections of overriders stored in global variables, all managed by static
constructors. cpp:initialize[] sets up global dispatch data. If these variables
are truly global, dynamically loaded libraries can add classes, methods and
overriders to a registry at runtime. Such is the case on Linux, and other
POSIX-like platforms.

After loading a dynamic library, the program must call `initialize` to
rebuild the dispatch tables.
If `virtual_ptr`{empty}s already exist

A dynamic library can add classes and methods to an existing policy, and
overriders to existing methods.
`initialize` must then be called to rebuild the dispatch tables.

This leads to a problem: any `virtual_ptr` in existence before `initialize` is
called is invalidated. This also applies to vptrs that are stored inside objects
by cpp:inplace_vptr[].

NOTE: This applies only to cases where a dynamic library adds to an
_existing_ policy.
Even if the dynamic library itself uses open-methods, for example as an
implementation detail, but it uses its own policy, there is no issue.

The solution is to use a policy that contains the cpp:indirect_vptr[]
policy.
Instead of storing the vptr directly, it stores a reference to the vptr.

Here is an example:

[source,c++]
----
include::example$dl.hpp[tag=header]
----

NOTE: The policy must be passed to the method as well as the
`virtual_ptr`{empty}s.

The `indirect_vptr` policy tells `virtual_ptr` to use a pointer to the vptr.
Even tough the value of the vptr changes when `initialize` is called, the
vptrs are stored in the same place (the policy's `static_vptr<Class>`
variables).

We can now register the classes and and provide an overrider:

[source,c++]
----
include::example$dl_main.cpp[tag=main]
----

At this point we only have one overrider.
Animals of all species ignore one another:

[source,c++]
----
include::example$dl_main.cpp[tag=before_dlopen]
----

Let's load a dynamic library containing this code:

[source,c++]
----
include::example$dl_shared.cpp[tag=dl_shared]
----

Now back to `main`.
We need to call `initialize` before using any

[source,c++]
----
include::example$dl_main.cpp[tag=dlopen]
----

After unloading the library, we must call `initialize` again:

[source,c++]
----
include::example$dl_main.cpp[tag=after_dlclose]
----
