
## Motivation

Consider a class hierarchy that represents and evaluates arithmetic expressions:

[source,cpp]
----
include::{examplesdir}/ast_virtual_function.cpp[tag=all]
----

We want to add a new operation that prints the expression in postfix notation.


How do we do it?

There is a simple way: add a new virtual function:

[source,cpp]
----
struct Node {
    // as before
    virtual void postfix(std::ostream& os) const = 0;
};

struct Variable : Node {
    // as before
    virtual void postfix(std::ostream& os) const override { os << v; }
};

struct Plus : Node {
    // as before
    void postfix(std::ostream& os) const override {
        left.postfix(os); os << ' '; right.postfix(os); os << " +";
    }
};

struct Times : Node {
    // as before
    void postfix(std::ostream& os) const override {
        left.postfix(os); os << ' '; right.postfix(os); os << " *";
    }
};

int main() {
    Variable a{2}, b{3}, c{4};
    Plus d{a, b}; Times e{d, c};
    e.postfix(std::cout);
    std::cout << " = " << e.value() << "\n"; // prints "20"
}
----

If the classes are part of a small, self-contained program, this may be the
reasonable solution. Otherwise, there are serious problems with this approach.

* We need to modify all the classes in the hierarchy, which may be
  numerous and spread across multiple files, in a real program. This assumes that we have access to their source code.

* We need to recompile all the files that use the Node classes, because the
layout of their virtual function tables (v-tables) has changed.

* If the Node classes put in a library, and used in several programs, they all
pull all the overriders of the `postfix` function, even if they don't use
`postfix` at all.

* They also pull `postfix`{empty}'s transitive dependencies, in this case `std::ostream`, locales, facets, exceptions, etc.

In C++, this problem is often handled via the Visitor design pattern. We may
still need to modify Node to equip it with Visitor support, but once that is
done, we can add all the operations we want, albeit in a clumsy fashion. Sadly,
it is now difficult to add new _Node_ classes, because we have to modify the
Visitor's interface, and all its implementations, and recompile all the files
that use the Visitor.

Paul Graham said that design patterns are essentially workarounds for features
that are missing in less expressive languages. Indeed, in some languages, our
problem does not even exist. C# has extension classes. Lisp, Clojure, Dylan,
Julia, Cecil, TADS, and others, have multi-methods.

But wait! What do multi-methods have to do with this problem? There is no
multiple dispatch going on here! The thing is, "multi-methods" is not a very
good name. In this document, we will use the term "open-methods" instead (or
just "methods").

An open-method is like a virtual function, but it exists outside of a class, as
a free-standing function. We can create all the open-methods we need, without
ever needing to modify existing classes.

This library implements open-methods for C++17 and above.
